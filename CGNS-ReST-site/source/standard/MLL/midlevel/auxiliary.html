<!-- CGNS Mid-Level Library - Auxiliary Data -->

<html>
<head>
<meta http-equiv="Content-Style-Type" content="text/css">
<title> CGNS Mid-Level Library - Auxiliary Data </title>
</head>

<h2>Auxiliary Data</h2>

<ul>
<li> <a href="#refstate">Reference State</a>
     <ul>
     <li> <code><b>cg_state_write</b></code> - Create <code>ReferenceState_t</code> node
     <li> <code><b>cg_state_size</b></code> - Get length of reference state description string.
     <li> <code><b>cg_state_read</b></code> - Read text description of reference state.
     </ul>
<li> <a href="#gravity">Gravity</a>
     <ul>
     <li> <code><b>cg_gravity_write</b></code> - Create <code>Gravity_t</code> node
     <li> <code><b>cg_gravity_read</b></code> - Read <code>Gravity_t</code> node
     </ul>
<li> <a href="#convergence">Convergence History</a>
     <ul>
     <li> <code><b>cg_convergence_write</b></code> - Create <code>ConvergenceHistory_t</code> node
     <li> <code><b>cg_convergence_read</b></code> - Read <code>ConvergenceHistory_t</code> node
     </ul>
<li> <a href="#integral">Integral Data</a>
     <ul>
     <li> <code><b>cg_integral_write</b></code> - Create <code>IntegralData_t</code> node
     <li> <code><b>cg_nintegrals</b></code> - Get number of <code>IntegralData_t</code> nodes
     <li> <code><b>cg_integral_read</b></code> - Get name of an <code>IntegralData_t</code> node
     </ul>
<li> <a href="#userdefined">User-Defined Data</a>
     <ul>
     <li> <code><b>cg_user_data_write</b></code> - Create <code>UserDefinedData_t</code> node
     <li> <code><b>cg_nuser_data</b></code> - Get number of <code>UserDefinedData_t</code> nodes
     <li> <code><b>cg_user_data_read</b></code> - Get name of an <code>UserDefinedData_t</code> node
     </ul>
<li> <a href="#free">Freeing Memory</a>
     <ul>
     <li> <code><b>cg_free</b></code> - Release library-allocated memory
     </ul>
</ul>

<a name="refstate"></a>
<h3>Reference State</h3>

<i>Node</i>: <code>ReferenceState_t</code>
             (<a href="../sids/misc.html#ReferenceState">SIDS</a>,
              <a href="../filemap/nodes.html#ReferenceState">File Mapping</a>)

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_state_write(<span class=in>char *StateDescription</span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_state_read(<span class=out><i>char **StateDescription</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
        <code><b>call cg_state_write_f(<span class=in>StateDescription</span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_state_size_f(<span class=out><i>Size</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_state_read_f(<span class=out><i>StateDescription</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>

<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>StateDescription</code><td><code>&nbsp;&nbsp;</code>
   <td>Text description of reference state.
<tr valign=baseline><td>
   <td><code>Size</code><td>
   <td>Number of characters in the <code>StateDescription</code> string
       (Fortran interface only) - integer.
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<p>
The function <code>cg_state_write</code> creates the
<code>ReferenceState_t</code> node and must be called even if
<code>StateDescription</code> is undefined (i.e., a blank string).
The descriptors, data arrays, data class, and dimensional units
characterizing the <code>ReferenceState_t</code> data structure may be added
to this data structure after its creation.

<p>
The function <code>cg_state_read</code> reads the <code>StateDescription</code>
of the local <code>ReferenceState_t</code> node.
If <code>StateDescription</code> is undefined in the CGNS database, this
function returns a null string.
If <code>StateDescription</code> exists, the library will allocate the space
to store the description string, and return the description string to
the application.
It is the responsibility of the application to free this space when it
is no longer needed by a call to
<a href="#free"><code>cg_free(StateDescription)</code></a>.

<a name="gravity"></a>
<h3>Gravity</h3>

<i>Node</i>: <code>Gravity_t</code>
             (<a href="../sids/misc.html#Gravity">SIDS</a>,
              <a href="../filemap/nodes.html#Gravity">File Mapping</a>)

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_gravity_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>float *GravityVector</span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_gravity_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=out><i>float *GravityVector</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
        <code><b>call cg_gravity_write_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>GravityVector</span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m<br>
<tr><td nowrap>
        <code><b>call cg_gravity_read_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=out><i>GravityVector</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>fn</code><td><code>&nbsp;&nbsp;</code>
   <td>CGNS file index number.
<tr valign=baseline><td>
   <td><code>B</code><td>
   <td>Base index number, where 1 &le; <code>B</code> &le; <code>nbases</code>.
<tr valign=baseline><td>
   <td><code>GravityVector</code><td>
   <td>Components of the gravity vector.
       The number of components must equal <code>PhysicalDimension</code>.
       (In Fortran, this is an array of Real*4 values.)
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<a name="convergence"></a>
<h3>Convergence History</h3>

<i>Node</i>: <code>ConvergenceHistory_t</code>
             (<a href="../sids/misc.html#ConvergenceHistory">SIDS</a>,
              <a href="../filemap/nodes.html#ConvergenceHistory">File Mapping</a>)

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_convergence_write(<span class=in>int niterations</span>,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>char *NormDefinitions</span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_convergence_read(<span class=out><i>int *niterations</i></span>,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>char **NormDefinitions</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
        <code><b>call cg_convergence_write_f(<span class=in>niterations</span>, <span class=in>NormDefinitions</span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m<br>
<tr><td nowrap>
        <code><b>call cg_convergence_read_f(<span class=out><i>niterations</i></span>, <span class=out><i>NormDefinitions</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>niterations</code><td><code>&nbsp;&nbsp;</code>
   <td>Number of iterations for which convergence information is recorded.
<tr valign=baseline><td>
   <td><code>NormDefinitions</code><td>
   <td>Description of the convergence information recorded in the data arrays.
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<p>
The function <code>cg_convergence_write</code> creates a
<code>ConvergenceHistory_t</code> node.
It must be the first one called when recording convergence history data.
The <code>NormDefinitions</code> may be left undefined (i.e., a blank string).
After creation of this node, the descriptors, data arrays, data class,
and dimensional units characterizing the <code>ConvergenceHistory_t</code>
data structure may be added.

<p>
The function <code>cg_convergence_read</code> reads a
<code>ConvergenceHistory_t</code> node.
If <code>NormDefinitions</code> is not defined in the CGNS database, this
function returns a null string.
If <code>NormDefinitions</code> exists, the library will allocate the space
to store the description string, and return the description string to
the application.
It is the responsibility of the application to free this space when it
is no longer needed by a call to
<a href="#free"><code>cg_free(NormDefinitions)</code></a>.

<a name="integral"></a>
<h3>Integral Data</h3>

<i>Node</i>: <code>IntegralData_t</code>
             (<a href="../sids/misc.html#IntegralData">SIDS</a>,
              <a href="../filemap/nodes.html#IntegralData">File Mapping</a>)

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_integral_write(<span class=in>char *Name</span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_nintegrals(<span class=out><i>int *nintegrals</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_integral_read(<span class=in>int Index</span>, <span class=out><i>char *Name</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
        <code><b>call cg_integral_write_f(<span class=in>Name</span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_nintegrals_f(<span class=out><i>nintegrals</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_integral_read_f(<span class=in>Index</span>, <span class=out><i>Name</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>Name</code><td><code>&nbsp;&nbsp;</code>
   <td>Name of the <code>IntegralData_t</code> data structure.
<tr valign=baseline><td>
   <td><code>nintegrals</code><td>
   <td>Number of <code>IntegralData_t</code> nodes under current node.
<tr valign=baseline><td>
   <td><code>Index</code><td>
   <td>Integral data index number, where 1 &le; <code>Index</code> &le; <code>nintegrals</code>.
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<a name="userdefined"></a>
<h3>User-Defined Data</h3>

<i>Node</i>: <code>UserDefinedData_t</code>
             (<a href="../sids/misc.html#UserDefinedData">SIDS</a>,
              <a href="../filemap/nodes.html#UserDefinedData">File Mapping</a>)

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_user_data_write(<span class=in>char *Name</span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_nuser_data(<span class=out><i>int *nuserdata</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_user_data_read(<span class=in>int Index</span>, <span class=out><i>char *Name</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
        <code><b>call cg_user_data_write_f(<span class=in>Name</span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_nuser_data_f(<span class=out><i>nuserdata</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_user_data_read_f(<span class=in>Index</span>, <span class=out><i>Name</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>nuserdata</code><td><code>&nbsp;&nbsp;</code>
   <td>Number of <code>UserDefinedData_t</code> nodes under current node.
<tr valign=baseline><td>
   <td><code>Name</code><td>
   <td>Name of the <code>UserDefinedData_t</code> node.
<tr valign=baseline><td>
   <td><code>Index</code><td>
   <td>User-defined data index number, where 1 &le; <code>Index</code> &le; <code>nuserdata</code>.
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<p>
After accessing a particular <code>UserDefinedData_t</code> node using
<a href="navigating.html#goto"><code>cg_goto</code></a>, the
<a href="location.html#ptset">Point Set functions</a> may be used to
read or write point set information for the node.
The function <a href="location.html#gridlocation"><code>cg_gridlocation_write</code></a>
may also be used to specify the location of the data with respect to the
grid (e.g., <code>Vertex</code> or <code>FaceCenter</code>).

<p>
Multiple levels of <code>UserDefinedData_t</code> nodes may be written and
retrieved by positioning via <a href="navigating.html#goto"><code>cg_goto</code></a>.
E.g.,
<pre>
   ier = cg_goto(fn, B, "Zone_t", Z, "UserDefinedData_t", ud1, 
                 "UserDefinedData_t", ud2, "UserDefinedData_t", ud3, "end");
</pre>


<a name="free"></a>
<h3>Freeing Memory</h3>

<br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_free(<span class=in>void *data</span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;w&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>data</code><td><code>&nbsp;&nbsp;</code>
   <td>Data allocated by the Mid-Level Library.
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<p>
This function does not affect the structure of a CGNS file; it is
provided as a convenience to free memory allocated by the Mid-Level
Library.
This isn't necessary in Fortran, and thus an equivalent Fortran function
is not provided.

<p>
The functions that are used to allocate memory for return values are
<a href="descriptor.html#descriptor"><code>cg_descriptor_read</code></a>,
<a href="#convergence"><code>cg_convergence_read</code></a>,
<a href="families.html#geometry"><code>cg_geo_read</code></a>,
<a href="links.html"><code>cg_link_read</code></a>,
and <a href="#refstate"><code>cg_state_read</code></a>.
Each of these may allocate space to contain the data returned
to the application.
It is the responsibility of the application to free this data when it is
no longer needed.
Calling <code>cg_free</code> is identical to calling the standard C function
<code>free</code>, however it is probably safer in that the memory is
freed in the same module in which it is created, particularly when the
Mid-Level Library is a shared library or DLL.
The routine checks for NULL data and will return <code>CG_ERROR</code> in
this case, otherwise it returns <code>CG_OK</code>.

<p>

</body>
</html>
