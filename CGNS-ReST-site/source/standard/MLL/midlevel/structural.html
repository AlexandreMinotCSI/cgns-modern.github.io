<!-- CGNS Mid-Level Library - Structural Nodes -->

<html>
<head>
<meta http-equiv="Content-Style-Type" content="text/css">
<title> CGNS Mid-Level Library - Structural Nodes </title>
</head>


<h2>Structural Nodes</h2>

<ul>
<li> <a href="#base">CGNS Base Information</a>
     <ul>
     <li> <code><b>cg_base_write</b></code> - Create and/or write to a CGNS base node
     <li> <code><b>cg_nbases</b></code> - Get number of CGNS base nodes in file
     <li> <code><b>cg_base_read</b></code> - Read CGNS base information
     <li> <code><b>cg_cell_dim</b></code> - Get the cell dimension for the CGNS base
     </ul>
<li> <a href="#zone">Zone Information</a>
     <ul>
     <li> <code><b>cg_zone_write</b></code> - Create and/or write to a zone node
     <li> <code><b>cg_nzones</b></code> - Get number of zones in base
     <li> <code><b>cg_zone_read</b></code> - Read zone information
     <li> <code><b>cg_zone_type</b></code> - Get type of zone (structured or unstructured)
     <li> <code><b>cg_index_dim</b></code> - Get the index dimension for the CGNS zone
     </ul>
<li> <a href="#simulationtype">Simulation Type</a>
     <ul>
     <li> <code><b>cg_simulation_type_write</b></code> - Write simulation type
     <li> <code><b>cg_simulation_type_read</b></code> - Read simulation type
     </ul>
</ul>

<a name="base"></a>
<h3>CGNS Base Information</h3>

<i>Node</i>: <code>CGNSBase_t</code>
             (<a href="../sids/cgnsbase.html#CGNSBase">SIDS</a>,
              <a href="../filemap/nodes.html#CGNSBase">File Mapping</a>)

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_base_write(<span class=in>int fn</span>, <span class=in>char *basename</span>, <span class=in>int cell_dim</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>int phys_dim</span>, <span class=out><i>int *B</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_nbases(<span class=in>int fn</span>, <span class=out><i>int *nbases</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_base_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=out><i>char *basename</i></span>, <span class=out><i>int *cell_dim</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>int *phys_dim</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_cell_dim(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=out><i>int *cell_dim</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
        <code><b>call cg_base_write_f(<span class=in>fn</span>, <span class=in>basename</span>, <span class=in>cell_dim</span>, <span class=in>phys_dim</span>, <span class=out><i>B</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_nbases_f(<span class=in>fn</span>, <span class=out><i>nbases</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_base_read_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=out><i>basename</i></span>, <span class=out><i>cell_dim</i></span>, <span class=out><i>phys_dim</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_cell_dim_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=out><i>cell_dim</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>

<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>fn</code><td><code>&nbsp;&nbsp;</code>
   <td>CGNS file index number.
<tr valign=baseline><td>
   <td><code>B</code><td>
   <td>Base index number, where 1 &le; <code>B</code> &le; <code>nbases</code>.
<tr valign=baseline><td>
   <td><code>nbases</code><td>
   <td>Number of bases present in the CGNS file <code>fn</code>.
<tr valign=baseline><td>
   <td><code>basename</code><td>
   <td>Name of the base.
<tr valign=baseline><td>
   <td><code>cell_dim</code><td>
   <td>Dimension of the cells; 3 for volume cells, 2 for surface cells
       and 1 for line cells.
<tr valign=baseline><td>
   <td><code>phys_dim</code><td>
   <td>Number of coordinates required to define a vector in the field.
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<a name="zone"></a>
<h3>Zone Information</h3>

<i>Node</i>: <code>Zone_t</code>
             (<a href="../sids/cgnsbase.html#Zone">SIDS</a>,
              <a href="../filemap/nodes.html#Zone">File Mapping</a>)

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_zone_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>char *zonename</span>, <span class=in>cgsize_t *size</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>ZoneType_t zonetype</span>, <span class=out><i>int *Z</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_nzones(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=out><i>int *nzones</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_zone_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=out><i>char *zonename</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>cgsize_t *size</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_zone_type(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=out><i>ZoneType_t *zonetype</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_index_dim(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=out><i>int *index_dim</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
        <code><b>call cg_zone_write_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>zonename</span>, <span class=in>size</span>, <span class=in>zonetype</span>, <span class=out><i>Z</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_nzones_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=out><i>nzones</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_zone_read_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=out><i>zonename</i></span>, <span class=out><i>size</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_zone_type_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=out><i>zonetype</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_index_dim_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=out><i>index_dim</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>

<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>fn</code><td><code>&nbsp;&nbsp;</code>
   <td>CGNS file index number.
<tr valign=baseline><td>
   <td><code>B</code><td>
   <td>Base index number, where 1 &le; <code>B</code> &le; <code>nbases</code>.
<tr valign=baseline><td>
   <td><code>Z</code><td>
   <td>Zone index number, where 1 &le; <code>Z</code> &le; <code>nzones</code>.
<tr valign=baseline><td>
   <td><code>nzones</code><td>
   <td>Number of zones present in base <code>B</code>.
<tr valign=baseline><td>
   <td><code>zonename</code><td>
   <td>Name of the zone.
<tr valign=baseline><td>
   <td><code>size</code><td>
   <td>Number of vertices, cells, and boundary vertices in each
       (<i>index</i>)-dimension.  For structured grids, the dimensions have unit stride in the array (e.g., <code>[NVertexI, NVertexJ, NVertexK, NCellI, NCellJ, NCellK, NBoundVertexI, NBoundVertexJ, NBoundVertexK]</code>).
       <p>
       Note that for unstructured grids, the number of cells is the
       number of highest order elements.
       Thus, in three dimensions it's the number of 3-D cells, and in
       two dimensions it's the number of 2-D cells.
       <p>
       Also for unstructured grids, if the nodes are sorted between
       internal nodes and boundary nodes, the optional parameter
       <code>NBoundVertex</code> must be set equal to the number of boundary
       nodes.
       By default, <code>NBoundVertex</code> equals zero, meaning that the
       nodes are unsorted.
       <p>
       Note that a non-zero value for <code>NBoundVertex</code> only applies
       to unstructured grids.
       For structured grids, the <code>NBoundVertex</code> parameter always
       equals 0 in all directions.<br><br>
       <table cellspacing=0 cellpadding=0 noborder>
       <tr valign=baseline>
          <th align=left scope=col>Mesh Type</td><td><code>&nbsp;&nbsp;</code></td>
          <th align=left scope=col>Size
       <tr valign=baseline>
          <td nowrap>3D structured</td><td></td>
          <td><code>NVertexI, NVertexJ, NVertexK</code><br>
              <code>NCellI, NCellJ, NCellK</code><br>
              <code>NBoundVertexI = 0, NBoundVertexJ = 0, NBoundVertexK = 0</code>
       <tr valign=baseline>
          <td nowrap>2D structured</td><td></td>
          <td><code>NVertexI, NVertexJ</code><br>
              <code>NCellI, NCellJ</code><br>
              <code>NBoundVertexI = 0, NBoundVertexJ = 0</code>
       <tr valign=baseline>
          <td>3D unstructured</td><td></td>
          <td><code>NVertex, NCell3D, NBoundVertex</code>
       <tr valign=baseline>
          <td>2D unstructured</td><td></td>
          <td><code>NVertex, NCell2D, NBoundVertex</code>
       </table><br>
<tr valign=baseline><td>
   <td><code>zonetype</code><td>
   <td>Type of the zone.
       The admissible types are <code>Structured</code> and <code>Unstructured</code>.
<tr valign=baseline><td>
   <td><code>index_dim</code><td>
   <td>Index dimension for the zone. For Structured zones, this will
       be the base cell dimension and for Unstructured zones it will
       be 1</td>
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<p>
Note: When a CGNS file is opened via the cg_open() MLL function, the zones are sorted 
<i>alphanumerically</i> by name (the creation order is ignored/discarded).  This mechanism is
provided to enable ordinal zone indexing.  Therefore, if ordinal zone indexing is desired,
it is considered good standard
practice to always <u>choose zone names to 
be alphabetically increasing.</u>  For example, Zone0001, Zone0002, etc. is appropriate for up to
9999 zones.
<p>
(Important: Because the cgnsview tool uses the low-level cgio API, it does not sort the zones
by name and zone order presented may not match that of the MLL API.  Generally, cgnsview
presents the zones in creation order for both ADF and HDF5 formats.  One exception is CGNS files
that are either created or opened using the HDF5 v1.6 library (or older) will always be presented
alphabetically (creation order tracking was added to HDF5 in v1.8).)
<!--Note that the zones are sorted alphanumerically to insure that
they can always be retrieved in the same order (for the same
model).
<em>Therefore, users must name their zones alphanumerically to ensure proper
retrieval.</em>-->

<a name="simulationtype"></a>
<h3>Simulation Type</h3>

<i>Node</i>: <code>SimulationType_t</code>
             (<a href="../sids/cgnsbase.html#SimulationType">SIDS</a>,
              <a href="../filemap/nodes.html#SimulationType">File Mapping</a>)

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_simulation_type_write(<span class=in>int fn</span>, <span class=in>int B</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>SimulationType_t SimulationType</span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_simulation_type_read(<span class=in>int fn</span>, <span class=in>int B</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>SimulationType_t SimulationType</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
        <code><b>call cg_simulation_type_write_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>SimulationType</span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_simulation_type_read_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=out><i>SimulationType</i></span>, <span class=out><i>ier</i></span>)</b></code></b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>

<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>fn</code><td><code>&nbsp;&nbsp;</code>
   <td>CGNS file index number.
<tr valign=baseline><td>
   <td><code>B</code><td>
   <td>Base index number, where 1 &le; <code>B</code> &le; <code>nbases</code>.
<tr valign=baseline><td>
   <td><code>SimulationType</code><td>
   <td>Type of simulation.
       Valid types are <code>CG_Null</code>, <code>CG_UserDefined</code>,
       <code>TimeAccurate</code>, and <code>NonTimeAccurate</code>.
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<p>

</body>
</html>
